import { Request, Response, NextFunction } from 'express';
import { logger } from '../utils/logger';

export const vulnerabilityLogger = (req: Request, res: Response, next: NextFunction) => {
  const startTime = Date.now();
  
  // Log all requests with detailed information (overly verbose - vulnerable)
  const requestLog = {
    timestamp: new Date().toISOString(),
    method: req.method,
    url: req.originalUrl,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    headers: req.headers, // Exposes all headers
    query: req.query,
    body: req.body, // May contain sensitive data
    params: req.params,
    session: (req as any).session,
    cookies: req.cookies
  };

  // Check for common vulnerability patterns
  const vulnerabilityChecks = {
    sqlInjection: checkSQLInjection(req),
    xss: checkXSS(req),
    pathTraversal: checkPathTraversal(req),
    cmdInjection: checkCommandInjection(req),
    xxe: checkXXE(req),
    idor: checkIDOR(req),
    authBypass: checkAuthBypass(req)
  };

  // Log if any vulnerabilities detected
  const detectedVulns = Object.entries(vulnerabilityChecks)
    .filter(([, detected]) => detected)
    .map(([vuln]) => vuln);

  if (detectedVulns.length > 0) {
    logger.warn('VULNERABILITY_ATTEMPT', {
      ...requestLog,
      vulnerabilities: detectedVulns,
      patterns: vulnerabilityChecks
    });
  } else {
    logger.info('REQUEST', requestLog);
  }

  // Override response.json to log response data
  const originalJson = res.json;
  res.json = function(body: any) {
    const duration = Date.now() - startTime;
    
    logger.info('RESPONSE', {
      statusCode: res.statusCode,
      duration,
      body: body, // Logs response data (may contain sensitive info)
      headers: res.getHeaders()
    });
    
    return originalJson.call(this, body);
  };

  next();
};

// SQL Injection detection
function checkSQLInjection(req: Request): boolean {
  const sqlPatterns = [
    /(\'|\\\'|;|\|\||--)/i,
    /(union|select|insert|delete|update|drop|create|alter|exec|execute)/i,
    /(\*|;|\|\||\+)/,
    /(or\s+1=1|and\s+1=1)/i,
    /(drop\s+table|union\s+select)/i
  ];

  const checkValue = (value: any): boolean => {
    if (typeof value === 'string') {
      return sqlPatterns.some(pattern => pattern.test(value));
    }
    if (typeof value === 'object' && value !== null) {
      return Object.values(value).some(checkValue);
    }
    return false;
  };

  return checkValue(req.query) || checkValue(req.body) || checkValue(req.params);
}

// XSS detection
function checkXSS(req: Request): boolean {
  const xssPatterns = [
    /<script/i,
    /javascript:/i,
    /on\w+\s*=/i,
    /<iframe/i,
    /<object/i,
    /<embed/i,
    /eval\(/i,
    /alert\(/i,
    /document\.cookie/i
  ];

  const checkValue = (value: any): boolean => {
    if (typeof value === 'string') {
      return xssPatterns.some(pattern => pattern.test(value));
    }
    if (typeof value === 'object' && value !== null) {
      return Object.values(value).some(checkValue);
    }
    return false;
  };

  return checkValue(req.query) || checkValue(req.body) || checkValue(req.params);
}

// Path Traversal detection
function checkPathTraversal(req: Request): boolean {
  const pathPatterns = [
    /\.\./,
    /\/\.\./,
    /\.\.\\/,
    /\%2e\%2e/i,
    /\%2f/i,
    /\%5c/i
  ];

  return pathPatterns.some(pattern => 
    pattern.test(req.url) || 
    pattern.test(JSON.stringify(req.query)) ||
    pattern.test(JSON.stringify(req.body))
  );
}

// Command Injection detection
function checkCommandInjection(req: Request): boolean {
  const cmdPatterns = [
    /;.*?cat/i,
    /\|.*?ls/i,
    /&.*?whoami/i,
    /`.*?pwd/i,
    /\$\(.*?\)/,
    /\\x/i
  ];

  const checkValue = (value: any): boolean => {
    if (typeof value === 'string') {
      return cmdPatterns.some(pattern => pattern.test(value));
    }
    if (typeof value === 'object' && value !== null) {
      return Object.values(value).some(checkValue);
    }
    return false;
  };

  return checkValue(req.query) || checkValue(req.body) || checkValue(req.params);
}

// XXE detection
function checkXXE(req: Request): boolean {
  const xxePatterns = [
    /<!DOCTYPE/i,
    /<!ENTITY/i,
    /SYSTEM\s+["']/i,
    /file:\/\//i,
    /http:\/\//i,
    /&\w+;/
  ];

  const checkValue = (value: any): boolean => {
    if (typeof value === 'string') {
      return xxePatterns.some(pattern => pattern.test(value));
    }
    return false;
  };

  return checkValue(req.body);
}

// IDOR detection (Insecure Direct Object Reference)
function checkIDOR(req: Request): boolean {
  // Check for numeric IDs in URLs that might be sequential
  const idPattern = /\/(\d+)($|\/|\?)/;
  const match = req.url.match(idPattern);
  
  if (match) {
    const id = parseInt(match[1]);
    // Log potential IDOR attempt
    logger.info('POTENTIAL_IDOR', {
      url: req.url,
      id: id,
      method: req.method,
      userAgent: req.get('User-Agent')
    });
    return true;
  }
  
  return false;
}

// Authentication bypass detection
function checkAuthBypass(req: Request): boolean {
  const authBypassPatterns = [
    /admin/i,
    /root/i,
    /bypass/i,
    /true/i
  ];

  // Check for auth bypass in various fields
  const authFields = ['username', 'email', 'user', 'login', 'auth'];
  const body = req.body || {};
  
  return authFields.some(field => {
    const value = body[field];
    if (typeof value === 'string') {
      return authBypassPatterns.some(pattern => pattern.test(value));
    }
    return false;
  });
}

export default vulnerabilityLogger; 